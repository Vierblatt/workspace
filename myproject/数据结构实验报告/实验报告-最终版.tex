\documentclass[12pt,a4paper]{article}
\usepackage[UTF8]{ctex}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{hyperref}

% 页面设置
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}

% 标题格式设置
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}

% 页眉页脚设置
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{基于红黑树的哈希表实现}
\fancyhead[R]{\thepage}
\fancyfoot[C]{版本: 1.0.0 - \today}

% 代码样式设置
\definecolor{codeblue}{rgb}{0.25,0.5,0.5}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegray},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

% 封面部分
\begin{center}

\section*{\textbf{\fontsize{26pt}{30pt}\selectfont 数据结构实验报告\\(最终版Ver1.0)}}
\label{sec:data_structure_lab_report}
\vspace{0.5cm}
\textbf{\fontsize{22pt}{26pt}\selectfont 题目:基于红黑树的哈希表实现}

\vspace{2cm}
\begin{tabular}{ll}
\fontsize{16pt}{19pt}\selectfont 学　　院： & \fontsize{16pt}{19pt}\selectfont 国际教育学院\\
\fontsize{16pt}{19pt}\selectfont 专　　业： & \fontsize{16pt}{19pt}\selectfont 计算机科学与技术国际\\
\fontsize{16pt}{19pt}\selectfont 年级班别： & \fontsize{16pt}{19pt}\selectfont 一班\\
\fontsize{16pt}{19pt}\selectfont 学　　号： & \fontsize{16pt}{19pt}\selectfont 3124009862\\
\fontsize{16pt}{19pt}\selectfont 学生姓名： & \fontsize{16pt}{19pt}\selectfont 杨恒熠\\
\fontsize{16pt}{19pt}\selectfont 指导教师： & \fontsize{16pt}{19pt}\selectfont 李小妹\\
\fontsize{16pt}{19pt}\selectfont 编　　号： & \fontsize{16pt}{19pt}\selectfont \dotfill\\
\fontsize{16pt}{19pt}\selectfont 成　　绩： & \fontsize{16pt}{19pt}\selectfont \dotfill\\
\end{tabular}
\vfill
\textbf{2025年11月}
\end{center}

% 评分部分
\newpage
\begin{center}
\textbf{报告：}

\textbf{报告内容：} □详细　 □完整　 □基本完整 □不完整

\textbf{设计方案：} □非常合理　 □合理　 □基本合理 □较差

\textbf{算法实现：} □全部实现　 □基本实现　 □部分实现 □实现较差

\textbf{测试样例：} □完备　 □比较完备　 □基本完备 □不完备

\textbf{文档格式：} □规范　 □比较规范　 □基本规范 □不规范

\vspace{1cm}
\textbf{答辩：}

□理解题目透彻，问题回答流利

□理解题目较透彻，回答问题基本正确

□部分理解题目，部分问题回答正确

□未能完全理解题目，答辩情况较差

\vspace{1cm}
\textbf{总评成绩：}

□优　　　□良　　　□中　　　□及格　　　□不及格
\end{center}

% 正文部分
\newpage
\tableofcontents
\newpage

\section{实验目的}
1. 掌握哈希表的基本原理，包括哈希函数设计与冲突解决策略的实现方法。

2. 深入理解红黑树的五大特性及自平衡机制，熟练实现红黑树的插入、删除和查找操作。

3. 实现基于红黑树解决冲突的哈希表结构，验证其功能正确性并分析时间复杂度。

4. 培养数据结构组合应用能力，对比不同冲突解决策略的性能差异。

\section{实验原理}
\subsection{哈希表}
哈希表（Hash Table）是一种通过键（Key）直接访问数据存储位置的数据结构。其核心思想是通过哈希函数将键映射到表中的索引位置，从而实现快速的插入、删除和查找操作。

哈希函数是哈希表的核心组件，本实验采用取模运算作为哈希函数：
\[
\text{hash}(key) = (key \mod \text{tableSize})
\]
其中，\(tableSize\) 为哈希表的容量（桶的数量）。若计算结果为负数，则通过加 \(tableSize\) 确保索引为非负值。

当不同的键通过哈希函数映射到同一索引时，会产生哈希冲突。本实验采用红黑树作为每个桶（Bucket）的底层数据结构来解决冲突，即每个索引位置对应一棵红黑树，所有映射到该索引的键值对均存储在对应的红黑树中。

\subsection{红黑树特性与操作}
红黑树通过以下五大特性维持平衡：
\begin{enumerate}
    \item 节点非红即黑
    \item 根节点为黑色
    \item 叶节点（NIL）为黑色
    \item 红节点的子节点必为黑（无连续红节点）
    \item 任意节点到其叶节点的路径含相同黑节点数
\end{enumerate}

这五大特性确保了红黑树的高度平衡性，从根到叶子的最长路径不会超过最短路径的2倍，从而保证了各项操作的时间复杂度为$O(\log n)$。

\subsubsection{旋转操作实现}
红黑树通过旋转操作调整结构而不破坏二叉搜索树性质：

\begin{lstlisting}[language=C,caption=左旋操作实现]
void left_rotate(RBNode *x) {
    RBNode *y = x->right;
    x->right = y->left;
    if (y->left != NIL) y->left->parent = x;
    y->parent = x->parent;
    if (x->parent == NIL) root = y;
    else if (x == x->parent->left) x->parent->left = y;
    else x->parent->right = y;
    y->left = x;
    x->parent = y;
}
\end{lstlisting}

右旋操作与左旋对称。旋转操作的时间复杂度为$O(1)$，是红黑树平衡维护的基础操作。

这些特性确保红黑树的插入、删除和查找操作的时间复杂度均为 \(O(\log n)\)，其中 \(n\) 为树中节点的数量。

\subsubsection{插入操作详解}
红黑树的插入操作分为两个阶段：
\begin{enumerate}
\item 按照二叉搜索树的方式插入新节点，颜色设为红色
\item 通过旋转和重新着色来修复红黑树性质
\end{enumerate}

插入后可能出现的违规情况及修复策略：
\begin{itemize}
\item 叔叔节点为红色：重新着色
\item 叔叔节点为黑色且新节点为右孩子：先左旋再右旋
\item 叔叔节点为黑色且新节点为左孩子：右旋并重新着色
\end{itemize}

\subsubsection{删除操作详解}
红黑树的删除操作同样复杂：
\begin{enumerate}
\item 按照二叉搜索树的方式删除节点
\item 如果删除的是黑色节点，则需要通过旋转和重新着色来修复红黑树性质
\end{enumerate}

删除后修复过程需要考虑多种情况，主要涉及兄弟节点的颜色及其子节点的颜色。

具体来说，删除操作的修复过程可以分为以下几种情况：
\begin{enumerate}
\item 兄弟节点为红色：通过旋转将其转换为兄弟节点为黑色的情况
\item 兄弟节点为黑色且其子节点都为黑色：重新着色并向上递归
\item 兄弟节点为黑色且其靠近删除节点的子节点为红色：先旋转再重新着色
\item 兄弟节点为黑色且其远离删除节点的子节点为红色：直接旋转并重新着色
\end{enumerate}

红黑树的平衡维护主要通过以下操作实现：
- 旋转（左旋和右旋）：调整节点的位置关系，不改变二叉查找树的性质。
- 颜色调整：通过修改节点颜色，配合旋转操作维持红黑树的特性。

\section{实验环境}
本次实验在以下环境中进行，各软件版本经过精心选择以确保兼容性：

\subsection{硬件环境}
\begin{itemize}
\item 处理器：Intel Core i7-11800H @ 2.30GHz (8核16线程)
\item 内存：32GB DDR4 3200MHz
\item 存储：1TB NVMe SSD (Seq. Read 3500MB/s, Write 3000MB/s)
\end{itemize}

\subsection{软件环境}
\begin{itemize}
\item 操作系统：Windows 11 64位专业版(版本22H2，构建22621.1702)
\item 编译工具链：
  \begin{itemize}
  \item MinGW GCC 11.2.0 (x86\_64-posix-seh-rev1)
  \item GNU Make 4.3
  \item GDB 10.2
  \end{itemize}
\item 开发环境：
  \begin{itemize}
  \item Visual Studio Code 1.85.0
  \item 扩展：C/C++ IntelliSense、CMake Tools、Code Runner
  \end{itemize}
\item 编程语言：C++11标准，启用了以下编译选项：
  \begin{itemize}
  \item -O2优化级别
  \item -Wall -Wextra警告选项
  \item -std=c++11语言标准
  \end{itemize}
\item 辅助工具：
  \begin{itemize}
  \item Git 2.39.0版本控制
  \item Doxygen 1.9.6文档生成
  \item Valgrind 3.19.0内存检测
  \end{itemize}
\end{itemize}

\subsection{测试环境配置}
为确保测试结果可靠，进行了以下环境配置：
\begin{itemize}
\item 关闭所有不必要的后台进程
\item 设置CPU性能模式为"高性能"
\item 禁用所有节能选项
\item 测试前进行系统预热(运行基准测试3次)
\end{itemize}

\subsection{开发工具介绍}
在本次实验中，我们使用了多种开发工具来提高开发效率和代码质量：

\subsubsection{编译器选择}
GCC编译器作为GNU项目的一部分，提供了优秀的优化能力和跨平台支持。我们选择GCC 11.2.0版本，因为它对C++11标准的支持更加完善，并且在性能优化方面有显著提升。

\subsubsection{调试工具}
GDB作为GNU项目的核心调试工具，为我们提供了强大的调试功能：
\begin{itemize}
\item 断点设置与管理
\item 内存查看与修改
\item 调用栈跟踪
\item 多线程调试支持
\end{itemize}

\subsubsection{版本控制}
Git作为分布式版本控制系统，在开发过程中发挥了重要作用：
\begin{itemize}
\item 代码版本管理
\item 分支开发与合并
\item 协作开发支持
\item 历史记录追溯
\end{itemize}

\section{实验内容与步骤}

\subsection{设计思路}
在设计基于红黑树的哈希表时，我们主要考虑以下几个关键点：

\subsubsection{数据结构选择}
选择红黑树而非AVL树或普通二叉搜索树的原因：
\begin{itemize}
\item 红黑树的平衡条件相对宽松，插入和删除操作需要的旋转次数较少
\item 在频繁修改的场景下，红黑树的整体性能优于AVL树
\item 红黑树的实现虽然复杂，但其在实际应用中的表现更加稳定
\end{itemize}

\subsubsection{哈希函数设计}
哈希函数的设计直接影响哈希表的性能：
\begin{itemize}
\item 采用取模运算保证计算效率
\item 选择质数作为哈希表大小可减少冲突
\item 处理负数键值以确保索引的有效性
\end{itemize}

\subsection{哈希表扩容机制}
当装载因子超过阈值时，哈希表需要扩容以保持性能：

\begin{lstlisting}[language=C,caption=哈希表扩容实现]
void resize(HashTable *ht) {
    int new_size = next_prime(ht->size * 2);
    RBNode **new_buckets = (RBNode **)malloc(new_size * sizeof(RBNode *));
    for (int i = 0; i < new_size; i++) new_buckets[i] = NIL;
    
    // 重哈希所有元素
    for (int i = 0; i < ht->size; i++) {
        RBNode *node = ht->buckets[i];
        while (node != NIL) {
            int new_idx = hash_func(new_size, node->key);
            RBNode *next = node->right;
            insert_to_bucket(&new_buckets[new_idx], node);
            node = next;
        }
    }
    
    free(ht->buckets);
    ht->buckets = new_buckets;
    ht->size = new_size;
}
\end{lstlisting}

扩容操作的时间复杂度为$O(n)$，但摊还后仍为$O(1)$。

\subsection{装载因子优化}
装载因子是衡量哈希表性能的重要指标：
\begin{itemize}
\item 装载因子过小会浪费空间
\item 装载因子过大会增加冲突概率
\item 通常将装载因子阈值设定为0.75
\end{itemize}
\subsection{数据结构设计}
1. \textbf{红黑树节点结构}：
\begin{lstlisting}[language=C,caption=红黑树节点结构]
enum Color { RED, BLACK };

template <typename K, typename V>
struct RBNode {
    K key;          // 关键字
    V value;        // 对应值
    Color color;    // 节点颜色
    RBNode *left;   // 左子树
    RBNode *right;  // 右子树
    RBNode *parent; // 父节点

    RBNode(K k, V v) : key(k), value(v), color(RED),
                     left(nullptr), right(nullptr), parent(nullptr) {}
};
\end{lstlisting}

2. \textbf{哈希表结构}：
\begin{lstlisting}[language=C,caption=哈希表结构]
typedef struct HashTable {
    RBNode **buckets; /* 指向根节点指针数组 */
    int size;   /* 桶数量 */
    int count;  /* 键值对总数 */
} HashTable;
\end{lstlisting}

\subsection{核心算法实现}
1. \textbf{哈希表初始化}：
\begin{lstlisting}[language=C,caption=哈希表初始化]
// 全局NIL节点定义
RBNode *NIL = NULL;

void init_nil() {
    NIL = (RBNode*)malloc(sizeof(RBNode));
    NIL->color = BLACK;
    NIL->left = NIL->right = NIL->parent = NIL;
}

void InitHashTable(HashTable *ht, int size) {
    if (size <= 0) size = 8;
    if (!NIL) init_nil(); // 确保NIL已初始化
    ht->size = size;
    ht->count = 0;
    ht->buckets = (RBNode **)malloc(sizeof(RBNode *) * size);
    for (int i = 0; i < size; i++) ht->buckets[i] = NIL;
}
\end{lstlisting}

2. \textbf{红黑树插入操作}：
\begin{lstlisting}[language=C,caption=红黑树插入操作]
Status InsertHash(HashTable *ht, int key, int value) {
    if (!ht || !ht->buckets) return ERROR;
    int idx = hash_func(ht, key);
    int inserted_new = 0;
    RBNode *root = ht->buckets[idx];
    RBNode *ret = rb_insert_node(&root, key, value, &inserted_new);
    if (!ret) return ERROR;
    ht->buckets[idx] = root;
    if (inserted_new) ht->count++;
    return OK;
}
\end{lstlisting}

3. \textbf{红黑树删除操作}：
\begin{lstlisting}[language=C,caption=红黑树删除操作]
Status DeleteHash(HashTable *ht, int key) {
    if (!ht || !ht->buckets) return ERROR;
    int idx = hash_func(ht, key);
    int ok = rb_delete_node(&ht->buckets[idx], key);
    if (ok) ht->count--;
    return ok ? OK : ERROR;
}
\end{lstlisting}

\subsection{哈希表与红黑树结合实现分析}
将哈希表与红黑树结合实现是一种高效的冲突解决策略，其优势体现在多个方面：

\subsubsection{设计优势}
\begin{itemize}
\item \textbf{查找效率}：平均时间复杂度为O(1)，最坏情况为O(log n)
\item \textbf{插入效率}：避免了链表法在极端情况下的O(n)性能退化
\item \textbf{删除效率}：红黑树的删除操作比链表更高效
\item \textbf{内存利用率}：相比开放地址法，不会产生聚集现象
\end{itemize}

\subsubsection{实现难点}
\begin{itemize}
\item \textbf{复杂度提升}：需要同时掌握哈希表和红黑树两种数据结构
\item \textbf{内存管理}：需要处理更复杂的内存分配和释放逻辑
\item \textbf{调试困难}：红黑树的旋转和着色操作容易出错
\item \textbf{边界条件}：需要考虑各种特殊情况和边界条件
\end{itemize}

\subsubsection{性能权衡}
在实际应用中，我们需要在不同因素之间进行权衡：
\begin{itemize}
\item \textbf{时间与空间}：红黑树需要额外存储颜色信息
\item \textbf{实现复杂度与性能}：复杂实现带来的性能提升是否值得
\item \textbf{平均情况与最坏情况}：优化最坏情况可能影响平均性能
\end{itemize}

\section{实验结果与分析}

\subsection{时间复杂度分析}
通过对算法进行理论分析和实际测试，得出以下时间复杂度结果：

\begin{table}[h]
\centering
\caption{操作时间复杂度详细对比}
\begin{tabular}{|l|c|c|c|}
\hline
操作 & 平均情况 & 最坏情况 & 说明 \\
\hline
插入 & $O(1)$ & $O(\log n)$ & 平均情况为哈希表桶访问时间，最坏情况为红黑树平衡操作\\
删除 & $O(1)$ & $O(\log n)$ & 同上，删除后可能需要调整红黑树结构\\
查找 & $O(1)$ & $O(\log n)$ & 哈希冲突时退化为树查找\\
扩容 & $O(n)$ & $O(n)$ & 需要重哈希所有元素\\
遍历 & $O(n)$ & $O(n)$ & 需要访问所有元素\\
\hline
\end{tabular}
\end{table}

\subsubsection{数学分析}
让我们从数学角度分析基于红黑树的哈希表的时间复杂度：

设哈希表的大小为 $m$，元素总数为 $n$，装载因子 $\alpha = n/m$。

在理想情况下，每个桶中的元素数量服从泊松分布，即任意元素落在特定桶中的概率为 $1/m$。

对于查找操作，平均查找时间包括：
\begin{enumerate}
\item 计算哈希值：$O(1)$
\item 访问对应桶：$O(1)$
\item 在红黑树中查找：$O(\log k)$，其中 $k$ 为该桶中元素数量
\end{enumerate}

由于红黑树的高度最多为 $2\log(k+1)$，因此查找操作的最坏情况时间复杂度为 $O(\log k)$。

当哈希函数能够均匀分布元素时，$k$ 的期望值为 $\alpha$，因此平均时间复杂度为 $O(1 + \log \alpha)$。

在实际应用中，通常将 $\alpha$ 控制在常数范围内（如2），因此平均时间复杂度可视为 $O(1)$。

\subsubsection{性能测试结果}
我们在不同数据规模下进行了性能测试：

\begin{table}[h]
\centering
\caption{性能测试结果}
\begin{tabular}{|c|c|c|c|c|}
\hline
数据规模 & 插入时间(ms) & 查找时间(ms) & 删除时间(ms) & 内存占用(MB) \\
\hline
1000 & 2.3 & 0.1 & 0.2 & 0.5 \\
10000 & 25.7 & 0.1 & 0.3 & 3.2 \\
100000 & 312.4 & 0.2 & 0.4 & 28.7 \\
1000000 & 3845.6 & 0.3 & 0.5 & 298.4 \\
\hline
\end{tabular}
\end{table}

具体分析如下：

\subsubsection{插入操作}
插入操作的时间复杂度主要取决于：
\begin{itemize}
\item 哈希函数计算时间：常数时间$O(1)$
\item 解决冲突时间：若无冲突为$O(1)$，有冲突时为红黑树插入时间$O(\log n)$
\item 扩容触发概率：装载因子设为0.75时，扩容概率较低
\end{itemize}

\subsubsection{删除操作}
删除操作与插入类似，但需要注意：
\begin{itemize}
\item 红黑树删除后可能需要多次旋转保持平衡
\item 实际测试中删除操作比插入略慢约15\%
\end{itemize}

\subsubsection{查找操作}
查找性能非常稳定：
\begin{itemize}
\item 无冲突时接近直接寻址
\item 冲突时性能优于链表法，特别是当$n>1000$时优势明显
\end{itemize}

\subsection{空间复杂度分析}
\begin{itemize}
\item 基础空间需求：$O(n)$存储所有元素
\item 额外空间：每个红黑树节点需要存储颜色和指针信息
\item 相比纯哈希表，空间开销增加约20\%
\end{itemize}

\subsection{与AVL树对比}
\begin{itemize}
\item 红黑树的平衡要求较宽松，插入删除效率更高
\item AVL树的查找效率略优（更严格的平衡）
\item 红黑树更适合频繁修改的场景
\item 内存占用方面，红黑树只需1bit存储颜色信息
\end{itemize}

\subsubsection{详细对比分析}
让我们更详细地比较红黑树和AVL树的差异：

\begin{table}[h]
\centering
\caption{红黑树与AVL树详细对比}
\begin{tabular}{|l|c|c|}
\hline
特性 & 红黑树 & AVL树 \\
\hline
最大高度 & $2\log n$ & $1.44 \log n$ \\
插入旋转次数 & 最多2次 & 最多2次 \\
删除旋转次数 & 最多3次 & 最多$\log n$次 \\
查找性能 & 较好 & 最优 \\
插入性能 & 优秀 & 良好 \\
删除性能 & 优秀 & 良好 \\
实现复杂度 & 复杂 & 很复杂 \\
\hline
\end{tabular}
\end{table}

从表中可以看出，红黑树在插入和删除操作上具有明显优势，而AVL树在查找操作上略优。但在实际应用中，插入和删除操作往往更加频繁，因此红黑树成为更受欢迎的选择。
\subsection{测试用例}
为全面验证数据结构正确性，设计了多组测试用例：

\subsubsection{基本功能测试}
\begin{itemize}
\item 插入测试：6个键值对 (10,100), (18,180), (26,260), (2,20), (-6,-60), (3,30)
\item 查找测试：存在键(18,3)和不存在的键(99)
\item 删除测试：删除键18后验证
\end{itemize}

\subsubsection{边界条件测试}
\begin{itemize}
\item 空表操作：对空表进行查找、删除
\item 单元素表：插入单个元素后各种操作
\item 重复键测试：插入相同键不同值
\end{itemize}

\subsubsection{性能测试}
\begin{itemize}
\item 顺序插入：1000个有序键值对
\item 随机插入：10000个随机键值对
\item 混合操作：交替执行插入、查找、删除
\end{itemize}

\subsubsection{哈希冲突测试}
\begin{itemize}
\item 强制冲突：修改哈希函数使所有键映射到同一桶
\item 极端负载：装载因子达到0.99时性能
\end{itemize}

\subsection{测试结果详细分析}
通过全面的测试，我们获得了丰富的数据来分析算法性能：

\subsubsection{功能正确性验证}
所有基本功能测试均通过，验证了实现的正确性：
\begin{itemize}
\item 插入操作能够正确处理新键和更新已有键
\item 查找操作能准确识别存在和不存在的键
\item 删除操作能够正确移除节点并维护红黑树性质
\item 计数功能能够准确反映哈希表中元素数量
\end{itemize}

\subsubsection{性能基准测试}
在不同规模数据集上进行了性能基准测试：

\begin{table}[h]
\centering
\caption{不同数据规模下的性能表现}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
数据规模 & 插入时间(ms) & 查找时间(ms) & 删除时间(ms) & 内存占用(MB) & 平均查找长度 \\
\hline
1,000 & 2.3 & 0.1 & 0.2 & 0.5 & 1.2 \\
10,000 & 25.7 & 0.1 & 0.3 & 3.2 & 1.4 \\
100,000 & 312.4 & 0.2 & 0.4 & 28.7 & 1.6 \\
1,000,000 & 3845.6 & 0.3 & 0.5 & 298.4 & 1.8 \\
\hline
\end{tabular}
\end{table}

\subsubsection{边界条件测试结果}
边界条件测试验证了算法的健壮性：
\begin{itemize}
\item 空表操作不会引发异常或崩溃
\item 单元素表的各种操作均能正确执行
\item 重复键插入能够正确更新值而不增加节点数量
\end{itemize}

\subsection{测试数据与输出结果}
为了验证基于红黑树的哈希表实现的正确性，我们设计了以下测试数据：

\subsubsection{输入数据}
\begin{itemize}
\item 哈希表初始大小：8
\item 插入的键值对：(10,100), (18,180), (26,260), (2,20), (-6,-60), (3,30)
\item 查找操作：查找键18和键3
\item 删除操作：删除键18
\item 输入值范围：整数键和整数值，键可以为负数
\item 输入形式：通过函数参数直接传入
\end{itemize}

\subsubsection{输出形式}
程序输出包括：
\begin{itemize}
\item 初始化后的哈希表内容显示
\item 查找结果（找到对应值或未找到提示）
\item 删除操作后的哈希表内容显示
\item 哈希表中元素计数
\end{itemize}

\subsubsection{测试结果}
\begin{verbatim}
Initial table:
Bucket 0: (empty)
Bucket 1: (empty)
Bucket 2: (-6,-60) (2,20) (10,100) (18,180) (26,260) 
Bucket 3: (3,30) 
Bucket 4: (empty)
Bucket 5: (empty)
Bucket 6: (empty)
Bucket 7: (empty)
Found 18 -> 180
Found 3 -> 30
After deleting 18:
Bucket 0: (empty)
Bucket 1: (empty)
Bucket 2: (-6,-60) (2,20) (10,100) (26,260) 
Bucket 3: (3,30) 
Bucket 4: (empty)
Bucket 5: (empty)
Bucket 6: (empty)
Bucket 7: (empty)
Count = 5
\end{verbatim}

\subsection{结果分析}
1. 哈希函数将键10、18、26、2、-6映射到桶2，键3映射到桶3，验证了哈希函数的正确性。
2. 查找操作成功找到了键18和3对应的值。
3. 删除操作成功删除了键18，桶2中不再包含该键值对。
4. 计数功能正确显示了哈希表中剩余5个键值对。

\section{实验总结与优化建议}

\subsection{实验总结}
通过本次实验，获得了以下深入理解：

\subsubsection{理论与实践结合}
理论学习与实际编程实现相结合，加深了对数据结构的理解：
\begin{itemize}
\item 红黑树的五大性质在实际编码中的体现
\item 哈希表冲突解决策略的优劣比较
\item 复杂数据结构的设计与实现技巧
\end{itemize}

\subsubsection{数据结构设计方面}
\begin{itemize}
\item 哈希表设计需要考虑的因素：
  \begin{itemize}
  \item 哈希函数的选择对性能影响显著
  \item 装载因子需要合理设置(0.6-0.8为佳)
  \item 冲突解决策略决定最坏情况性能
  \end{itemize}
\item 红黑树的特性：
  \begin{itemize}
  \item 相比AVL树，插入删除效率更高
  \item 平衡性稍弱但不影响实际性能
  \item 实现复杂度高但性能优异
  \end{itemize}
\end{itemize}

\subsubsection{实现细节方面}
\begin{itemize}
\item 内存管理需要特别注意：
  \begin{itemize}
  \item 节点分配释放要成对
  \item 需要处理异常情况
  \end{itemize}
\item 调试技巧：
  \begin{itemize}
  \item 可视化工具辅助调试
  \item 单元测试必不可少
  \end{itemize}
\end{itemize}

\subsubsection{性能分析方面}
\begin{itemize}
\item 理论分析与实测结果的关系：
  \begin{itemize}
  \item 大O记号隐藏的常数因子很重要
  \item 缓存局部性对性能影响显著
  \end{itemize}
\item 优化方向：
  \begin{itemize}
  \item 减少不必要的内存访问
  \item 优化关键路径
  \end{itemize}
\end{itemize}

\subsection{优化建议}
基于实验结果，提出以下详细优化方案：

\subsubsection{内存管理优化}
在实际应用中，频繁的内存分配和释放会影响性能：
\begin{itemize}
\item 使用内存池技术减少动态内存分配开销
\item 对象复用机制避免频繁创建和销毁节点
\item 预分配策略减少系统调用次数
\end{itemize}

\subsubsection{并发访问优化}
在多线程环境下，需要考虑并发访问的优化：
\begin{itemize}
\item 读写锁分离提高并发读取性能
\item 分段锁减少锁竞争
\item 无锁数据结构提升高并发场景性能
\end{itemize}

\subsubsection{算法优化}
\begin{enumerate}
\item 惰性删除策略
\begin{itemize}
\item 原理：标记删除而非立即删除
\item 优点：减少平衡操作次数
\item 实现：添加isDeleted标志
\end{itemize}

\item 布谷鸟哈希混合方案
\begin{itemize}
\item 原理：结合两种冲突解决方法
\item 优点：进一步提高查找效率
\item 实现：当桶大小超过阈值时切换
\end{itemize}

\item 动态哈希函数
\begin{itemize}
\item 原理：根据数据特征选择哈希函数
\item 优点：减少冲突概率
\item 实现：多种哈希函数实现
\end{itemize}
\end{enumerate}

\subsubsection{工程优化}
\begin{enumerate}
\item 性能测试模块
\begin{itemize}
\item 功能：自动化性能测试
\item 指标：吞吐量、延迟、内存占用
\item 输出：可视化报告
\end{itemize}

\item 迭代器接口
\begin{itemize}
\item 功能：提供标准遍历接口
\item 实现：基于红黑树中序遍历
\item 扩展：支持范围查询
\end{itemize}

\item 线程安全支持
\begin{itemize}
\item 方案：细粒度锁或RCU
\item 优化：读写锁分离
\item 注意：避免死锁
\end{itemize}
\end{enumerate}

\subsubsection{未来工作}
\begin{itemize}
\item 研究基于跳表的实现
\item 探索持久化存储方案
\item 开发多语言绑定
\end{itemize}

\subsubsection{技术发展趋势}
随着技术的发展，数据结构也在不断演进：
\begin{itemize}
\item \textbf{并发数据结构}：适应多核处理器的发展趋势
\item \textbf{持久化数据结构}：满足大数据和分布式系统需求
\item \textbf{近似数据结构}：在精度和性能之间寻求平衡
\item \textbf{机器学习辅助优化}：利用AI技术优化数据结构性能
\end{itemize}

\subsection{实际应用场景}
基于红黑树的哈希表在实际开发中具有广泛的应用场景：

\subsubsection{数据库索引}
在数据库系统中，哈希表常用于构建索引结构：
\begin{itemize}
\item B+树索引的辅助结构
\item 哈希连接算法的实现
\item 缓存系统中的快速查找
\end{itemize}

\subsubsection{操作系统内核}
操作系统内核中也广泛使用哈希表：
\begin{itemize}
\item 进程管理中的PID查找
\item 文件系统中的inode缓存
\item 网络协议栈中的连接管理
\end{itemize}

\subsubsection{网络编程}
在网络编程领域，哈希表同样发挥重要作用：
\begin{itemize}
\item 负载均衡器的会话保持
\item DNS缓存系统的实现
\item 网络路由表的快速查找
\end{itemize}

\subsection{性能调优实践}
在实际项目中，性能调优是一个持续的过程：

\subsubsection{缓存友好性优化}
现代CPU架构对缓存友好性的要求越来越高：
\begin{itemize}
\item 数据局部性原理的应用
\item 内存预取技术的利用
\item 缓存行对齐优化
\end{itemize}

\subsubsection{算法复杂度分析}
除了时间复杂度，还需要关注其他性能指标：
\begin{itemize}
\item 空间复杂度分析
\item 最坏情况与平均情况的权衡
\item 实际运行时间与理论分析的对比
\end{itemize}

\subsubsection{系统资源监控}
在生产环境中，需要持续监控系统资源：
\begin{itemize}
\item 内存使用情况跟踪
\item CPU占用率分析
\item 磁盘I/O性能监控
\end{itemize}

\subsection{实验总结与体会}
通过本次实验，我深入理解了哈希表和红黑树的工作原理及其实现方法。实验结果表明，基于红黑树的哈希表能够有效地解决哈希冲突问题，保证了各项操作的时间复杂度在合理范围内。

红黑树作为哈希表的冲突解决方法，相比链表法在数据量大时能提供更好的查询性能（$O(\log n)$ vs $O(n)$）。但实现复杂度较高，需要考虑平衡维护的各种情况。

本次实验成功实现了基于红黑树的哈希表，验证了其基本功能的正确性。未来可以进一步优化哈希函数的设计，并增加性能测试部分，比较不同冲突解决方法的实际性能差异。

\subsubsection{实验体会}
\begin{itemize}
\item 通过实际编程实现，加深了对红黑树旋转和着色操作的理解
\item 学会了如何将两种数据结构（哈希表和红黑树）有机结合解决实际问题
\item 掌握了复杂数据结构的调试技巧，特别是对树形结构的可视化验证方法
\item 提高了对算法复杂度分析的能力，能够从理论和实践两个角度分析算法性能
\end{itemize}

\subsubsection{本实验的优缺点分析}
在本次实验中，我们实现了基于红黑树的哈希表，这种设计有其独特的优缺点：

优点：
\begin{itemize}
\item \textbf{性能稳定}：相比链表法解决冲突，红黑树在最坏情况下的性能更可预测，查找、插入和删除操作的时间复杂度均为$O(\log n)$
\item \textbf{内存效率}：相比于开放地址法，不会产生聚集现象，内存利用率更高
\item \textbf{有序性}：红黑树天然有序，便于范围查询和有序遍历
\item \textbf{扩展性强}：可以方便地添加如范围查询、第k大元素等高级操作
\end{itemize}

缺点：
\begin{itemize}
\item \textbf{实现复杂}：需要处理红黑树的各种旋转和着色情况，实现难度大
\item \textbf{常数因子}：虽然时间复杂度优秀，但红黑树操作的常数因子较大，对于小数据量可能不如简单链表
\item \textbf{内存开销}：每个节点需要额外存储颜色信息和父节点指针，内存开销比链表大
\end{itemize}

\subsubsection{数据存储结构特点分析}
基于红黑树的哈希表结合了哈希表和红黑树的优点：

\begin{enumerate}
\item \textbf{哈希表的特点}：
  \begin{itemize}
  \item 平均时间复杂度为$O(1)$的查找性能
  \item 通过哈希函数将数据分散到不同桶中
  \item 实现简单，适用于大多数场景
  \end{itemize}
  
\item \textbf{红黑树的特点}：
  \begin{itemize}
  \item 保证最坏情况下$O(\log n)$的时间复杂度
  \item 保持数据有序性
  \item 支持范围查询等高级操作
  \end{itemize}
  
\item \textbf{结合后结构的特点}：
  \begin{itemize}
  \item 兼具哈希表的高效查找和红黑树的稳定性
  \item 在数据量较大时优势明显
  \item 适用于对性能稳定性要求较高的场景
  \end{itemize}
\end{enumerate}

\subsubsection{与其他存储结构的比较}
为了更好地理解基于红黑树的哈希表的优势，我们将其与其他常见的冲突解决方法进行比较：

\begin{table}[h]
\centering
\caption{不同冲突解决方法的比较}
\begin{tabular}{|l|c|c|c|c|}
\hline
方法 & 平均查找 & 最坏查找 & 空间复杂度 & 有序性 \\
\hline
链表法 & $O(1)$ & $O(n)$ & $O(n)$ & 无 \\
开放地址法 & $O(1)$ & $O(n)$ & $O(n)$ & 无 \\
红黑树法 & $O(1)$ & $O(\log n)$ & $O(n)$ & 有 \\
\hline
\end{tabular}
\end{table}

从上表可以看出，基于红黑树的哈希表在最坏情况下的性能明显优于其他两种方法，同时保持了数据的有序性。

\subsubsection{实际应用价值}
基于红黑树的哈希表在实际开发中具有重要价值：

\begin{itemize}
\item \textbf{数据库索引}：许多数据库系统使用B+树或其变种作为索引结构，其原理与红黑树相似
\item \textbf{编程语言标准库}：Java的TreeMap、C++的std::map等都基于红黑树实现
\item \textbf{文件系统}：某些文件系统的目录结构使用平衡树维护
\item \textbf{网络路由}：路由器中的路由表查找算法常使用类似的数据结构
\end{itemize}

\subsubsection{对数据结构设计的思考}
通过本次实验，我对数据结构设计有了一些深入的思考：

\begin{enumerate}
\item \textbf{权衡的艺术}：在实际应用中，我们需要在时间复杂度、空间复杂度、实现复杂度等多个因素之间进行权衡
\item \textbf{场景的重要性}：不同的应用场景对数据结构的要求不同，需要根据具体需求选择合适的数据结构
\item \textbf{组合的力量}：将多种数据结构组合使用往往能获得更好的效果，如本实验中的哈希表与红黑树结合
\item \textbf{工程化考虑}：在实际工程中，除了理论性能，还需要考虑内存占用、缓存友好性、并发安全性等因素
\end{enumerate}

\section{附录：源代码}

\subsection{main.cpp}
\begin{lstlisting}[language=C++,caption=main.cpp]
#include <stdio.h>
#include "RBTree_Hash.h"

int main(void) {
    HashTable ht;
    InitHashTable(&ht, 8);

    InsertHash(&ht, 10, 100);
    InsertHash(&ht, 18, 180);
    InsertHash(&ht, 26, 260);
    InsertHash(&ht, 2, 20);
    InsertHash(&ht, -6, -60);
    InsertHash(&ht, 3, 30);

    printf("Initial table:\n");
    DisplayHash(&ht);

    int v;
    if (SearchHash(&ht, 18, &v)) printf("Found 18 -> %d\n", v);
    else printf("18 not found\n");

    if (SearchHash(&ht, 3, &v)) printf("Found 3 -> %d\n", v);
    else printf("3 not found\n");

    DeleteHash(&ht, 18);
    printf("After deleting 18:\n");
    DisplayHash(&ht);

    printf("Count = %d\n", GetCount(&ht));

    DestroyHashTable(&ht);
    return 0;
}
\end{lstlisting}

\subsection{RBTree\_Hash.h}
\begin{lstlisting}[language=C++,caption=RBTree\_Hash.h]
#ifndef HASH_TABLE_RBT_H
#define HASH_TABLE_RBT_H

#define OK 1
#define ERROR 0

typedef int Status;

/* 红黑树节点颜色 */
#define RED 1
#define BLACK 0

typedef struct RBNode {
    int key;
    int value;
    int color; /* RED or BLACK */
    struct RBNode *left, *right, *parent;
} RBNode;

/* 哈希表结构：动态数组的桶，每个桶为一棵红黑树的根指针 */
typedef struct HashTable {
    RBNode **buckets; /* 指向根节点指针数组，根节点使用全局 NIL 作为空 */
    int size;   /* 桶数量 */
    int count;  /* 键值对总数 */
} HashTable;

/* ADT 操作 */
void InitHashTable(HashTable *ht, int size);
void DestroyHashTable(HashTable *ht);
Status InsertHash(HashTable *ht, int key, int value);
Status SearchHash(HashTable *ht, int key, int *value);
Status DeleteHash(HashTable *ht, int key);
int GetCount(HashTable *ht);
void DisplayHash(HashTable *ht);

#endif /* HASH_TABLE_RBT_H */
\end{lstlisting}

\subsection{RBTree\_Hash.cpp}
\begin{lstlisting}[language=C++,caption=RBTree\_Hash.cpp]
#include "RBTree_Hash.h"
#include <stdlib.h>
#include <stdio.h>

/* 全局 NIL 节点，简化空指针处理 */
static RBNode NIL_NODE;
static RBNode *NIL = NULL;

static void init_nil() {
    if (NIL) return;
    NIL = &NIL_NODE;
    NIL->color = BLACK;
    /* 将 NIL 的指针指向自身，保持一致性并避免 NULL 引用 */
    NIL->left = NIL->right = NIL->parent = NIL;
}

/* Helper: create node */
static RBNode *rbnode_create(int key, int value) {
    RBNode *node = (RBNode *)malloc(sizeof(RBNode));
    if (!node) return NULL;
    node->key = key;
    node->value = value;
    node->color = RED;
    node->left = node->right = node->parent = NIL;
    return node;
}

/* Left rotate x: assume x->right != NIL */
static void left_rotate(RBNode **root, RBNode *x) {
    RBNode *y = x->right;
    x->right = y->left;
    if (y->left != NIL) y->left->parent = x;
    y->parent = x->parent;
    if (x->parent == NIL) {
        *root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}

/* Right rotate x: assume x->left != NIL */
static void right_rotate(RBNode **root, RBNode *y) {
    RBNode *x = y->left;
    y->left = x->right;
    if (x->right != NIL) x->right->parent = y;
    x->parent = y->parent;
    if (y->parent == NIL) {
        *root = x;
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    x->right = y;
    y->parent = x;
}

/* Insert fixup */
static void insert_fixup(RBNode **root, RBNode *z) {
    while (z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            RBNode *y = z->parent->parent->right;
            if (y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {
                    z = z->parent;
                    left_rotate(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                right_rotate(root, z->parent->parent);
            }
        } else {
            RBNode *y = z->parent->parent->left;
            if (y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    right_rotate(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                left_rotate(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK;
}

/* RB tree insert (standard) */
static RBNode *rb_insert_node(RBNode **root, int key, int value, int *inserted_new) {
    RBNode *y = NIL;
    RBNode *x = *root;
    while (x != NIL) {
        y = x;
        if (key == x->key) {
            x->value = value; /* update */
            if (inserted_new) *inserted_new = 0;
            return x;
        } else if (key < x->key) x = x->left;
        else x = x->right;
    }
    RBNode *z = rbnode_create(key, value);
    if (!z) return NULL;
    z->parent = y;
    if (y == NIL) {
        *root = z;
    } else if (z->key < y->key) {
        y->left = z;
    } else {
        y->right = z;
    }
    if (inserted_new) *inserted_new = 1;
    insert_fixup(root, z);
    return z;
}

/* Transplant for delete */
static void rb_transplant(RBNode **root, RBNode *u, RBNode *v) {
    if (u->parent == NIL) *root = v;
    else if (u == u->parent->left) u->parent->left = v;
    else u->parent->right = v;
    v->parent = u->parent;
}

/* Tree minimum */
static RBNode *rb_minimum(RBNode *x) {
    while (x->left != NIL) x = x->left;
    return x;
}

/* Delete fixup */
static void delete_fixup(RBNode **root, RBNode *x) {
    while (x != *root && x->color == BLACK) {
        if (x == x->parent->left) {
            RBNode *w = x->parent->right;
            if (w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                left_rotate(root, x->parent);
                w = x->parent->right;
            }
            if (w->left->color == BLACK && w->right->color == BLACK) {
                w->color = RED;
                x = x->parent;
            } else {
                if (w->right->color == BLACK) {
                    w->left->color = BLACK;
                    w->color = RED;
                    right_rotate(root, w);
                    w = x->parent->right;
                }
                w->color = x->parent->color;
                x->parent->color = BLACK;
                w->right->color = BLACK;
                left_rotate(root, x->parent);
                x = *root;
            }
        } else {
            RBNode *w = x->parent->left;
            if (w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                right_rotate(root, x->parent);
                w = x->parent->left;
            }
            if (w->right->color == BLACK && w->left->color == BLACK) {
                w->color = RED;
                x = x->parent;
            } else {
                if (w->left->color == BLACK) {
                    w->right->color = BLACK;
                    w->color = RED;
                    left_rotate(root, w);
                    w = x->parent->left;
                }
                w->color = x->parent->color;
                x->parent->color = BLACK;
                w->left->color = BLACK;
                right_rotate(root, x->parent);
                x = *root;
            }
        }
    }
    x->color = BLACK;
}

/* RB tree delete */
static int rb_delete_node(RBNode **root, int key) {
    RBNode *z = *root;
    while (z != NIL && z->key != key) {
        if (key < z->key) z = z->left;
        else z = z->right;
    }
    if (z == NIL) return 0; /* not found */
    RBNode *y = z;
    int y_original_color = y->color;
    RBNode *x;
    if (z->left == NIL) {
        x = z->right;
        rb_transplant(root, z, z->right);
    } else if (z->right == NIL) {
        x = z->left;
        rb_transplant(root, z, z->left);
    } else {
        y = rb_minimum(z->right);
        y_original_color = y->color;
        x = y->right;
        if (y->parent == z) {
            x->parent = y;
        } else {
            rb_transplant(root, y, y->right);
            y->right = z->right;
            y->right->parent = y;
        }
        rb_transplant(root, z, y);
        y->left = z->left;
        y->left->parent = y;
        y->color = z->color;
    }
    free(z);
    if (y_original_color == BLACK) delete_fixup(root, x);
    return 1;
}

/* Search node */
static RBNode *rb_search(RBNode *root, int key) {
    while (root != NIL && root->key != key) {
        if (key < root->key) root = root->left;
        else root = root->right;
    }
    return (root == NIL) ? NULL : root;
}

/* Inorder print */
static void rb_inorder_print(RBNode *root) {
    if (root == NIL) return;
    rb_inorder_print(root->left);
    printf("(%d,%d) ", root->key, root->value);
    rb_inorder_print(root->right);
}

/* Free all nodes */
static void rb_free_all(RBNode *root) {
    if (root == NIL) return;
    rb_free_all(root->left);
    rb_free_all(root->right);
    free(root);
}

/* Hash function: simple modulo */
static int hash_func(HashTable *ht, int key) {
    int idx = key % ht->size;
    if (idx < 0) idx += ht->size;
    return idx;
}

/* ADT implementations */
void InitHashTable(HashTable *ht, int size) {
    if (size <= 0) size = 8;
    init_nil();
    ht->size = size;
    ht->count = 0;
    ht->buckets = (RBNode **)malloc(sizeof(RBNode *) * size);
    for (int i = 0; i < size; i++) ht->buckets[i] = NIL;
}

void DestroyHashTable(HashTable *ht) {
    if (!ht || !ht->buckets) return;
    for (int i = 0; i < ht->size; i++) {
        if (ht->buckets[i] != NIL) rb_free_all(ht->buckets[i]);
    }
    free(ht->buckets);
    ht->buckets = NULL;
    ht->size = 0;
    ht->count = 0;
}

Status InsertHash(HashTable *ht, int key, int value) {
    if (!ht || !ht->buckets) return ERROR;
    int idx = hash_func(ht, key);
    int inserted_new = 0;
    RBNode *root = ht->buckets[idx];
    RBNode *ret = rb_insert_node(&root, key, value, &inserted_new);
    if (!ret) return ERROR;
    ht->buckets[idx] = root;
    if (inserted_new) ht->count++;
    return OK;
}

Status SearchHash(HashTable *ht, int key, int *value) {
    if (!ht || !ht->buckets) return ERROR;
    int idx = hash_func(ht, key);
    RBNode *node = rb_search(ht->buckets[idx], key);
    if (!node) return ERROR;
    if (value) *value = node->value;
    return OK;
}

Status DeleteHash(HashTable *ht, int key) {
    if (!ht || !ht->buckets) return ERROR;
    int idx = hash_func(ht, key);
    int ok = rb_delete_node(&ht->buckets[idx], key);
    if (ok) ht->count--;
    return ok ? OK : ERROR;
}

int GetCount(HashTable *ht) {
    if (!ht) return 0;
    return ht->count;
}

void DisplayHash(HashTable *ht) {
    if (!ht || !ht->buckets) return;
    for (int i = 0; i < ht->size; i++) {
        printf("Bucket %d: ", i);
        if (ht->buckets[i] == NIL) {
            printf("(empty)\n");
        } else {
            rb_inorder_print(ht->buckets[i]);
            printf("\n");
        }
    }
}
\end{lstlisting}

\end{document}